package pair

import "fmt"

// Четвертый подход: подсчет. Этот подход возможен только в том случае, если мы знаем диапазон входных данных.
// Если мы это знаем, элементы в списке находятся в диапазоне от 0 до n-1.
//
// Мы можем зарезервировать список длиной n, и когда мы увидим элемент, мы можем увеличить его количество.
// Вместо хеш-таблицы в приведенном выше подходе мы будем использовать этот список и найдем пару.
//
// Подсчет просто использует список, поэтому вставка и поиск занимают постоянное время O (1),
// поэтому общая временная сложность алгоритма равна времени O (n).
// Пространственная сложность для создания списка счетчиков также равна O (n)

func CountingPair(data []int, value int) bool {
	ret := false
	n := value + 1
	countList := make([]int, n)

	for _, elem := range data {
		if elem < n {
			countList[elem] += 1
		}
	}

	for i := 0; i < n; i++ {
		if i <= value-i && countList[i] > 0 && countList[value-i] > 0 {
			fmt.Printf("Pair found: %d, %d\n", i, value-i)
			ret = true
			break
		}
	}

	if !ret {
		fmt.Println("Pair not found")
	}
	return ret
}
