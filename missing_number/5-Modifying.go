package missingnumber

// Пятый подход: вам разрешено изменять данный входной список.
// Измените данный входной список таким образом, чтобы
// при следующем сканировании можно было найти недостающий элемент.
// Когда вы просматриваете список по индексу «index», значение,
// сохраненное в списке, будет arr[index],
// поэтому добавьте число «n + 1» к arr[arr[index]].
// Всегда читайте значение из списка, используя оператор напоминания «%».
// Когда вы сканируете список в первый раз и изменяете все значения,
// то за одно сканирование вы можете увидеть, есть ли в списке какое-либо значение,
// меньшее, чем «n+1», этот индекс является недостающим числом.
// В этом подходе список сканируется два раза,
// а временная сложность этого алгоритма равна O (n).
// Пространственная сложность равна O(1).

// Описанный вами алгоритм является вариантом алгоритма
// для поиска отсутствующего числа в массиве,
// где элементы массива находятся в диапазоне от 0 до n-1,
// и вы можете изменять исходный массив.
// Этот алгоритм использует идею модификации исходного массива
// для отметки присутствующих чисел, что позволяет
// найти отсутствующее число при повторном сканировании массива.

func FindModifying(data []int) (int, bool) {
	size := len(data)

	// Первый проход: модификация массива
	// При первом проходе по массиву, находясь на индексе index,
	// значение в массиве будет data[index].
	for i := 0; i < size; i++ {
		// Операция % n используется для получения оригинального значения элемента,
		// если оно было изменено ранее.
		// Это модифицирует массив таким образом,
		// что если число i присутствует в массиве,
		// то элемент в позиции i (или i % n, если он уже был изменен) будет увеличен на n + 1.
		index := data[i] % size
		data[index] += size
	}

	// Второй проход: поиск числа
	// ищете элемент, который меньше n + 1.
	for i := 0; i < size; i++ {
		if data[i] < size {
			return i, true
		}
	}

	return 0, false
}
